{"meta":{"title":"JQH","subtitle":"博客笔记","description":"前后端等相关笔记","author":"jqh","url":"https://chenkun18.github.io"},"pages":[{"title":"404","date":"2023-11-02T03:13:25.000Z","updated":"2023-11-06T00:20:57.243Z","comments":true,"path":"404/index.html","permalink":"https://chenkun18.github.io/404/index.html","excerpt":"","text":""},{"title":"categories","date":"2023-11-01T07:29:48.000Z","updated":"2023-11-06T00:20:57.280Z","comments":true,"path":"categories/index.html","permalink":"https://chenkun18.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-11-01T08:24:06.000Z","updated":"2023-11-06T00:20:57.280Z","comments":true,"path":"tags/index.html","permalink":"https://chenkun18.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"参数校验","slug":"后端/springboot/csjy","date":"2024-01-10T08:49:39.000Z","updated":"2024-01-10T08:58:12.244Z","comments":true,"path":"2024/01/10/后端/springboot/csjy/","link":"","permalink":"https://chenkun18.github.io/2024/01/10/%E5%90%8E%E7%AB%AF/springboot/csjy/","excerpt":"","text":"SpringBoot参数校验","categories":[{"name":"后端","slug":"后端","permalink":"https://chenkun18.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://chenkun18.github.io/tags/SpringBoot/"},{"name":"SpringBoot项目必备","slug":"SpringBoot项目必备","permalink":"https://chenkun18.github.io/tags/SpringBoot%E9%A1%B9%E7%9B%AE%E5%BF%85%E5%A4%87/"},{"name":"SpringBoot参数校验","slug":"SpringBoot参数校验","permalink":"https://chenkun18.github.io/tags/SpringBoot%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://chenkun18.github.io/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"代理","slug":"其他/proxy","date":"2024-01-04T08:51:03.000Z","updated":"2024-01-04T09:27:48.855Z","comments":true,"path":"2024/01/04/其他/proxy/","link":"","permalink":"https://chenkun18.github.io/2024/01/04/%E5%85%B6%E4%BB%96/proxy/","excerpt":"","text":"代理https://cloud.tencent.com/developer/article/2353102 正向代理反向代理","categories":[{"name":"其他","slug":"其他","permalink":"https://chenkun18.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"正向代理","slug":"正向代理","permalink":"https://chenkun18.github.io/tags/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/"},{"name":"反向代理","slug":"反向代理","permalink":"https://chenkun18.github.io/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://chenkun18.github.io/categories/%E5%85%B6%E4%BB%96/"}]},{"title":"应用国际化","slug":"后端/springboot/gjh","date":"2024-01-04T04:59:23.000Z","updated":"2024-01-10T03:18:09.691Z","comments":true,"path":"2024/01/04/后端/springboot/gjh/","link":"","permalink":"https://chenkun18.github.io/2024/01/04/%E5%90%8E%E7%AB%AF/springboot/gjh/","excerpt":"","text":"应用国际化前端国际化 页面显示和用户界面的本地化 方案：React Intl、Vue I18n、Angular i18n 后端国际化 处理与业务逻辑和数据相关的国际化 概念 java.util.Locale类：本地化语言类，包含各个国家地区的语言languages org.springframework.context.MessageSource：其主要是根据Locale信息获取对应的国际化消息的集合，然后根据code获取对应的消息 org.springframework.web.servlet.LocaleResolver：设置当前会话默认的国际化语言 步骤 1、创建国际化文件resources/i18n/messages message.properties message_cn_ZH.properties message_en_GB.properties 2、yml指定国际化1234spring: messages: basename: i18n/messages encoding: UTF-8 3、创建国际化表i18n_message（除了可以存在配置文件，也可以存在数据库） 属性名 国家代码 对应内容 PASSWORD cn_ZH 密码 PASSWORD en_GB password AGE cn_ZH 年龄 AGE en_GB age 4、表对应实体类以及Dao123456789101112131415161718@Data@Builder@NoArgsConstructor@AllArgsConstructor@TableName(&quot;i18n_message&quot;)@ApiModel(description = &quot;国际化表&quot;)public class I18nMessage &#123; @ApiModelProperty(&quot;属性名&quot;) private String code; @ApiModelProperty(&quot;国家代码&quot;) private String locale; @ApiModelProperty(&quot;对应内容&quot;) private String message;&#125; 12@Mapperpublic interface I18nMessageMapper extends BaseMapper&lt;I18nMessage&gt; &#123; &#125; 5、自定义MessageSource类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485@Component(&quot;messageSource&quot;)public class CustomMessageSource extends AbstractMessageSource implements InitializingBean &#123; @Resource private I18nMessageMapper i18nMessageMapper; /** * 这个是用来缓存数据库中获取到的配置的（可以改到redis） * 数据库配置更改的时候可以调用reload方法重新加载 */ private static final Map&lt;String, Map&lt;String, String&gt;&gt; LOCAL_CACHE = new ConcurrentHashMap&lt;&gt;(); /** * Bean属性初始化完成之后执行 */ @Override public void afterPropertiesSet() &#123; this.reload(); &#125; /** * 重新加载消息到该类的Map缓存中 */ public void reload() &#123; LOCAL_CACHE.clear();// 清除该类的缓存 LOCAL_CACHE.putAll(this.loadAllMessageResources());// 加载所有的国际化资源 &#125; /** * 加载所有的国际化消息资源 * 同时从数据库和properties文件中读取国际化信息 * Map&lt;LanguageCode, Map&lt;code, 翻译&gt;&gt; */ private Map&lt;String, Map&lt;String, String&gt;&gt; loadAllMessageResources() &#123; // todo 从数据库中查询所有的国际化资源 List&lt;I18nMessage&gt; allLocaleMessage = i18nMessageMapper.selectAllList(); allLocaleMessage = Optional.OfNullable(allLocaleMessage).orElseGet(() -&gt; new ArrayList&lt;&gt;()); // 将查询到的国际化资源转换为 Map&lt;地区码, Map&lt;code, 信息&gt;&gt; 的数据格式 Map&lt;String, Map&lt;String, String&gt;&gt; localeMsgMap = allLocaleMessage.stream().collect(Collectors.groupingBy(I18message::getLocale, Collectors.toMap(I18nMessage::getCode, I18nMessage::getMessage))); // 获取国家地区List List&lt;Locale&gt; localeList = localeMsgMap.keySet().stream().map(Locale::new).collect(Collectors.toList()); for (Locale locale : localeList) &#123; // todo 按照国家地区来读取本地的国际化资源文件,我们的国际化资源文件放在i18n文件夹之下 ResourceBundle resourceBundle = ResourceBundle.getBundle(&quot;i18n/messages&quot;, locale); Set&lt;String&gt; keySet = resourceBundle.keySet();// 获取国际化资源文件中的key Map&lt;String, String&gt; msgFromFileMap = keySet.stream().collect(Collectors.toMap(Function.identity(), resourceBundle::getString));// 将 code=信息 格式的数据收集为 Map&lt;code,信息&gt; 的格式 // 将本地的国际化信息和数据库中的国际化信息合并 Map&lt;String, String&gt; localeFileMsgMap = localeMsgMap.get(locale.getLanguage()); localeFileMsgMap.putAll(msgFromFileMap);// 配置文件会覆盖数据库的 localeMsgMap.put(locale.getLanguage(), localeFileMsgMap); &#125; return localeMsgMap; &#125; /** * 缓存Map中get国际化资源 */ private String getSourceFromCacheMap(String code, Locale locale) &#123; String language = ObjectUtils.isEmpty(locale) ? LocaleContextHolder.getLocale().getLanguage() : locale.getLanguage(); // 获取缓存中对应语言的所有数据项 Map&lt;String, String&gt; propMap = LOCAL_CACHE.get(language); // 找到直接返回，找不到返回code return Optional.OfNullable(propMap.get(code)).orElse(code); &#125; /** * 实现方法，供AbstractMessageSource.getMessage方法内部使用 */ @Override protected MessageFormat resolveCode(String code, Locale locale) &#123; String msg = this.getSourceFromCacheMap(code, locale); return new MessageFormat(msg, locale); &#125; /** * 实现方法，供AbstractMessageSource.getMessage方法内部使用 */ @Override protected String resolveCodeWithoutArguments(String code, Locale locale) &#123; return this.getSourceFromCacheMap(code, locale); &#125;&#125; 6、自定义LocaleResolver国际化区域解析器，解析url或者header中的参数 1234567891011121314151617181920212223242526272829303132@Componentpublic class CustomLocaleResolver implements LocaleResolver &#123; /** * 根据当前请求解析当前请求的本地化信息 */ @Override public Locale resolveLocale(HttpServletRequest httpServletRequest) &#123; String l = httpServletRequest.getParameter(&quot;lang&quot;);// 请求url参数 String header = httpServletRequest.getHeader(&quot;lang&quot;);// 请求头参数 Locale locale = null;// 国际化，每一个locale对象都代表一个特定的政治文化，地区和创建方法 return Optional.OfNullable(l).map(i -&gt; &#123; // 判断请求url参数中是否有带lang参数（优先） String[] split = l.split(&quot;_&quot;);// 根据下划线分割 return new Locale(split[0], split[1]);// 创建国际化对象 &#125;).orElseGet(() -&gt; &#123; return Optional.OfNullable(header).map(i -&gt; &#123; // 判断请求头参数中是否有带lang参数 header = header.replaceAll(&quot;\\&quot;&quot;,&quot;&quot;);// 替换为空 String[] split = header.split(&quot;_&quot;);// 根据下划线分割 return new Locale(split[0], split[1]);// 创建国际化对象 &#125;).orElse(null); &#125;); &#125; /** * 设置当前请求、响应的本地化信息 */ @Override public void setLocale(HttpServletRequest httpServletRequest, @Nullable HttpServletResponse httpServletResponse, @Nullable Locale locale) &#123; &#125;&#125; 7、封装工具类 12345678910111213141516171819202122232425262728293031323334@Componentpublic class I18nMessageUtil &#123; private final MessageSource messageSource; /** * @param code 对应messages配置的key * @return String */ public String getMessage(String code)&#123; return getMessage(code, null); &#125; /** * @param code 对应messages配置的key * @param args 数组参数 * @return String */ public String getMessage(String code,Object[] args)&#123; return getMessage(code, args, &quot;&quot;); &#125; /** * @param code 对应messages配置的key * @param args 数组参数 * @param defaultMessage 没有设置key的时候的默认值 * @return String */ public String getMessage(String code,Object[] args,String defaultMessage)&#123; return messageSource.getMessage(code, args, defaultMessage, LocaleContextHolder.getLocale()); &#125;&#125; 使用场景 1、全局响应状态码（code）对应的消息（msg）国际化 法一：工具类中，将MessageSource做静态变量注入，提供几个静态方法进行国际化，在new Result()的时候调用静态方法进行国际化 【@Component+有参构造函数@Autowired注入】12345678910111213141516171819202122232425262728293031323334353637@Componentpublic class I18nMessageUtil &#123; private static MessageSource messageSource; @Autowired public I18nMessageUtil(MessageSource messageSource)&#123; I18nMessageUtil.messageSource = messageSource; &#125; /** * @param code 对应messages配置的key * @return String */ public static String getMessage(String code)&#123; return getMessage(code, null); &#125; /** * @param code 对应messages配置的key * @param args 数组参数 * @return String */ public static String getMessage(String code,Object[] args)&#123; return getMessage(code, args, &quot;&quot;); &#125; /** * @param code 对应messages配置的key * @param args 数组参数 * @param defaultMessage 没有设置key的时候的默认值 * @return String */ public static String getMessage(String code,Object[] args,String defaultMessage)&#123; return messageSource.getMessage(code, args, defaultMessage, LocaleContextHolder.getLocale()); &#125;&#125; 法二：AOP切面，@AfterReturning中获取返回对象，修改里面的属性值（对象是不能修改的成一个新的滴） 2、接口参数校验结果国际化 @NotBlank(message=&quot;&#123;xxx_err_code&#125;&quot;)","categories":[{"name":"后端","slug":"后端","permalink":"https://chenkun18.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"前端","slug":"后端/前端","permalink":"https://chenkun18.github.io/categories/%E5%90%8E%E7%AB%AF/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://chenkun18.github.io/tags/SpringBoot/"},{"name":"SpringBoot项目必备","slug":"SpringBoot项目必备","permalink":"https://chenkun18.github.io/tags/SpringBoot%E9%A1%B9%E7%9B%AE%E5%BF%85%E5%A4%87/"},{"name":"SpringBoot国际化","slug":"SpringBoot国际化","permalink":"https://chenkun18.github.io/tags/SpringBoot%E5%9B%BD%E9%99%85%E5%8C%96/"},{"name":"SpringBoot I18n","slug":"SpringBoot-I18n","permalink":"https://chenkun18.github.io/tags/SpringBoot-I18n/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://chenkun18.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"前端","slug":"后端/前端","permalink":"https://chenkun18.github.io/categories/%E5%90%8E%E7%AB%AF/%E5%89%8D%E7%AB%AF/"}]},{"title":"EnableAspectJAutoProxy","slug":"后端/springboot/EnableAspectJAutoProxy","date":"2024-01-02T04:47:32.000Z","updated":"2024-01-10T03:18:09.703Z","comments":true,"path":"2024/01/02/后端/springboot/EnableAspectJAutoProxy/","link":"","permalink":"https://chenkun18.github.io/2024/01/02/%E5%90%8E%E7%AB%AF/springboot/EnableAspectJAutoProxy/","excerpt":"","text":"@EnableAspectJAutoProxy 切面配置注解@EnableAspectJAutoProxy proxyTargetClass设置代理类型 exposeProxy设置代理类是否可以通过AopContext访问1234567891011121314151617181920212223242526package org.springframework.context.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(AspectJAutoProxyRegistrar.class)public @interface EnableAspectJAutoProxy &#123; /** * 是否要创建基于子类(CGLIB)的代理，而不是基于标准Java接口的代理。默认值是&#123;@code false&#125;。 */ boolean proxyTargetClass() default false; /** * 表明代理应该由AOP框架作为ThreadLocal公开，以便通过AopContext进行检索。 * 默认为关闭，即AopContext访问不到。 */ boolean exposeProxy() default false;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://chenkun18.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://chenkun18.github.io/tags/SpringBoot/"},{"name":"SpringBoot注解","slug":"SpringBoot注解","permalink":"https://chenkun18.github.io/tags/SpringBoot%E6%B3%A8%E8%A7%A3/"},{"name":"AOP切面","slug":"AOP切面","permalink":"https://chenkun18.github.io/tags/AOP%E5%88%87%E9%9D%A2/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://chenkun18.github.io/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"RestControllerAdvice","slug":"后端/springboot/RestControllerAdvice","date":"2023-12-18T01:07:28.000Z","updated":"2024-01-10T03:18:09.679Z","comments":true,"path":"2023/12/18/后端/springboot/RestControllerAdvice/","link":"","permalink":"https://chenkun18.github.io/2023/12/18/%E5%90%8E%E7%AB%AF/springboot/RestControllerAdvice/","excerpt":"","text":"@RestControllerAdvice状态码enum类12345678910111213141516171819202122232425262728293031public enum ResultCode &#123; SUCCESS(200,&quot;操作成功!&quot;), FAILURE(201,&quot;操作失败&quot;), /**系统相关的错误码：5开头**/ ERROR(500,&quot;系统异常，请稍后重试&quot;), /**参数相关的错误码：1开头**/ PARAM_ERROR(1000,&quot;参数异常&quot;), /**权限相关的错误码：2开头**/ INVALID_TOKEN(2001,&quot;访问令牌不合法&quot;), ACCESS_DENIED(2002,&quot;没有权限访问该资源&quot;), USERNAME_OR_PASSWORD_ERROR(2003,&quot;用户名或密码错误&quot;); private final int code; private final String message; ResultCode(int code, String message)&#123; this.code = code; this.message = message; &#125; public int getCode() &#123; return code; &#125; public String getMessage() &#123; return message; &#125;&#125; 统一返回值类1234567891011121314151617181920212223242526272829303132333435363738394041@Datapublic class Result&lt;T&gt; implements Serializable &#123; @Serial private static final long serialVersionUID = 1L; private Integer code; private String message; private T data; public Result(Integer code,String message)&#123; this.code = code; this.message = message; &#125; public Result(Integer code,String message,T data)&#123; this(code,message); this.data = data; &#125; public static &lt;T&gt; Result&lt;T&gt; success()&#123; return new Result&lt;&gt;(ResultCode.SUCCESS.getCode(),ResultCode.SUCCESS.getMessage()); &#125; public static &lt;T&gt; Result&lt;T&gt; success(T data)&#123; return new Result&lt;&gt;(ResultCode.SUCCESS.getCode(),ResultCode.SUCCESS.getMessage(),data); &#125; public static &lt;T&gt; Result&lt;T&gt; fail()&#123; return new Result&lt;&gt;(ResultCode.FAILURE.getCode(),ResultCode.FAILURE.getMessage()); &#125; public static &lt;T&gt; Result&lt;T&gt; fail(Integer code,String message)&#123; return new Result&lt;&gt;(code,message); &#125; public static &lt;T&gt; Result&lt;T&gt; error()&#123; return new Result&lt;&gt;(ResultCode.ERROR.getCode(),ResultCode.ERROR.getMessage()); &#125;&#125; 自定义运行时异常类123456789101112131415161718192021222324252627public class CustomException extends RuntimeException&#123; protected Integer code; protected String message; public CustomException(Integer code,String message,Throwable e) &#123; super(message,e); this.code = code; this.message = message; &#125; public CustomException(Integer code,String message)&#123; this(code,message,null); &#125; public void setCode(Integer code)&#123; this.code = code; &#125; public void setMessage(String message)&#123; this.message = message; &#125; public Integer getCode()&#123; return this.code; &#125;&#125; 全局异常处理类123456789101112131415161718192021222324@Slf4j@RestControllerAdvicepublic class GlobalException &#123; /** * 自定义异常处理 * @param e * @return */ @ExceptionHandler(value = CustomException.class) public Result&lt;Void&gt; customExceptionHandler(CustomException e) &#123; return Result.fail(e.getCode(),e.getMessage()); &#125; /** * 其他异常处理 * @param e * @return */ @ExceptionHandler(Exception.class) public Result&lt;Void&gt; exceptionHandler(Exception e) &#123; log.error(&quot;全局异常信息 ex=&#123;&#125;&quot;, e.getMessage(), e); return Result.error(); &#125;&#125; 示例1234@GetMapping(&quot;/test&quot;)public Result&lt;String&gt; test()&#123; throw new CustomException(ResultCode.USERNAME_OR_PASSWORD_ERROR.getCode(),ResultCode.USERNAME_OR_PASSWORD_ERROR.getMessage());&#125;","categories":[],"tags":[{"name":"全局异常处理","slug":"全局异常处理","permalink":"https://chenkun18.github.io/tags/%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"name":"统一响应","slug":"统一响应","permalink":"https://chenkun18.github.io/tags/%E7%BB%9F%E4%B8%80%E5%93%8D%E5%BA%94/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://chenkun18.github.io/tags/SpringBoot/"},{"name":"SpringBoot项目必备","slug":"SpringBoot项目必备","permalink":"https://chenkun18.github.io/tags/SpringBoot%E9%A1%B9%E7%9B%AE%E5%BF%85%E5%A4%87/"}],"keywords":[]},{"title":"mediasoup","slug":"前端/mediasoup/mediasoup","date":"2023-12-13T08:48:32.000Z","updated":"2023-12-13T08:54:14.792Z","comments":true,"path":"2023/12/13/前端/mediasoup/mediasoup/","link":"","permalink":"https://chenkun18.github.io/2023/12/13/%E5%89%8D%E7%AB%AF/mediasoup/mediasoup/","excerpt":"","text":"mediasoup mediasoup：C++ SFU和服务器端Node.js模块。 mediasoup-client：客户端JavaScript库。 libmediasoupclient：基于libwebrtc的C++库。 mediasoup-client-aiortc：aiortc Python库的处理程序。适用于构建Node.js应用程序，这些应用程序使用WebRTC连接到媒体汤服务器，并与之交换真实的音频、视频和DataChannel消息。 mediasoup-demo：演示应用程序的源代码。 mediasoup-broadcaster-demo：基于libmediasoupclient的C++应用程序，将系统麦克风和网络摄像头生成到mediasoup演示中。 mediasoup-website：项目网站 https://mediasoup.org","categories":[{"name":"前端","slug":"前端","permalink":"https://chenkun18.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"mediasoup","slug":"mediasoup","permalink":"https://chenkun18.github.io/tags/mediasoup/"},{"name":"webrtc","slug":"webrtc","permalink":"https://chenkun18.github.io/tags/webrtc/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://chenkun18.github.io/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"Node","slug":"前端/node/Node","date":"2023-12-13T08:25:41.000Z","updated":"2023-12-13T08:29:45.983Z","comments":true,"path":"2023/12/13/前端/node/Node/","link":"","permalink":"https://chenkun18.github.io/2023/12/13/%E5%89%8D%E7%AB%AF/node/Node/","excerpt":"","text":"nodeJS node -v","categories":[{"name":"前端","slug":"前端","permalink":"https://chenkun18.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"node","slug":"node","permalink":"https://chenkun18.github.io/tags/node/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://chenkun18.github.io/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"Spring Bean注入","slug":"后端/springboot/bean_inject","date":"2023-12-01T04:44:49.000Z","updated":"2024-01-04T05:02:32.535Z","comments":true,"path":"2023/12/01/后端/springboot/bean_inject/","link":"","permalink":"https://chenkun18.github.io/2023/12/01/%E5%90%8E%E7%AB%AF/springboot/bean_inject/","excerpt":"","text":"spring bean注入 @Resource：【javax.annotation.Resource】【注入可变的依赖】【作用在字段、方法和构造函数】【可根据名称显示匹配注入】【没找到抛异常】 @Autowired：【org.springframework.beans.factory.annotation.Autowired】【注入可变的依赖】【作用在字段、方法和构造函数】【没找到为null】 private final：【Spring Boot中使用构造函数注入】【注入不可变的依赖，确保字段的安全性和线程安全性】","categories":[{"name":"后端","slug":"后端","permalink":"https://chenkun18.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://chenkun18.github.io/tags/SpringBoot/"},{"name":"Bean注入","slug":"Bean注入","permalink":"https://chenkun18.github.io/tags/Bean%E6%B3%A8%E5%85%A5/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://chenkun18.github.io/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"onlyOfficeSpringBoot","slug":"其他/onlyOfficeSpringBoot","date":"2023-11-16T05:45:27.000Z","updated":"2023-11-21T07:55:37.301Z","comments":true,"path":"2023/11/16/其他/onlyOfficeSpringBoot/","link":"","permalink":"https://chenkun18.github.io/2023/11/16/%E5%85%B6%E4%BB%96/onlyOfficeSpringBoot/","excerpt":"","text":"类分析 Thymeleaf：https://blog.csdn.net/SoulNone/article/details/127572997 JPA：https://blog.csdn.net/zdwzzu2006/article/details/131751921 H2：https://blog.csdn.net/qq_29645505/article/details/97697093 JSON.simple：https://blog.csdn.net/fireroll/article/details/48708241 Gson：https://zhuanlan.zhihu.com/p/451745696 JWT：https://www.cnblogs.com/hlkawa/p/13675792.html JackSon：https://blog.csdn.net/oschina_40730821/article/details/124025086 devtools：https://juejin.cn/post/7027647026510692360 devtools：https://blog.csdn.net/weixin_43701894/article/details/129921286 FileUtility、DefaultFileUtility 作用：文件工具类，用于文件名后缀判断文件类型，文件大小限制 String getFileExtension(String url);从URL获取文件扩展名（文件后缀） long getMaxFileSize();获取最大文件大小 List&lt;String&gt; getFileExts();获取所有支持的文件扩展名（所有后缀） String getFileNameWithoutExtension(String url);获取没有扩展名的文件名 List&lt;String&gt; getConvertExts();获取可转换的文件扩展名列表（所有后缀） FileStorageMutator、FileStoragePathBuilder、LocalFileStorage 文件存储Mutator，文件存储路径生成器，本地文件存储 String updateFile(String fileName, byte[] bytes);更新文件（字节数据更新到文件） void createMeta(String fileName, String uid, String uname);创建文件元信息 DocumentManager、DefaultDocumentManager- ServiceConverter、DefaultServiceConverterFileController 文件上传接口：【post】/upload 入参：文件、用户id 作用：用于用户自己上传一个文件，然后在线编辑 文件转换接口：【post】/converter 入参：Converter、用户id、语言 文件删除接口：【post】/delete 入参：Converter 文件下载接口：【post】/download 入参：Converter","categories":[{"name":"后端","slug":"后端","permalink":"https://chenkun18.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"onlyOffice","slug":"onlyOffice","permalink":"https://chenkun18.github.io/tags/onlyOffice/"},{"name":"onlyOfficeSpringBoot","slug":"onlyOfficeSpringBoot","permalink":"https://chenkun18.github.io/tags/onlyOfficeSpringBoot/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://chenkun18.github.io/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"注解@PostConstruct","slug":"后端/java/PostConstruct","date":"2023-11-10T08:40:43.000Z","updated":"2023-11-10T08:44:32.594Z","comments":true,"path":"2023/11/10/后端/java/PostConstruct/","link":"","permalink":"https://chenkun18.github.io/2023/11/10/%E5%90%8E%E7%AB%AF/java/PostConstruct/","excerpt":"","text":"","categories":[{"name":"后端","slug":"后端","permalink":"https://chenkun18.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"java注解","slug":"java注解","permalink":"https://chenkun18.github.io/tags/java%E6%B3%A8%E8%A7%A3/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://chenkun18.github.io/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"日志","slug":"后端/springboot/Logs","date":"2023-11-10T05:48:51.000Z","updated":"2024-01-10T03:18:09.697Z","comments":true,"path":"2023/11/10/后端/springboot/Logs/","link":"","permalink":"https://chenkun18.github.io/2023/11/10/%E5%90%8E%E7%AB%AF/springboot/Logs/","excerpt":"","text":"日志系统日志 程序执行时输出的debug、info、warn、error等不同级别的程序执行记录信息； 给程序员或运维看的，一般在出现异常问题的时候，可以通过系统日志中记录的关键参数信息和异常提示，快速排除故障。 操作日志 用户实际业务操作行为的记录，这些信息一般存储在数据库里，如什么时间哪个用户点了某个菜单、修改了哪个配置等这类业务操作行为，这些日志信息是给普通用户或系统管理员看到。 需求分析 1、记录用户的业务操作行为，记录的字段有：操作人、操作时间、操作功能、日志类型、操作内容描述、操作内容报文、操作前内容报文 2、提供一个可视化的页面，可以查询用户的业务操作行为，对重要操作回溯； 3、提供一定的管理功能，必要的时候可以对用户的误操作回滚； 反面实现 1、每个接口里都加一段记录业务操作日志的记录； 2、每个接口里都要捕获一下异常，记录异常业务操作日志； 硬编码实现的业务操作日志管理功能的问题 业务操作日志收集与业务逻辑耦合严重 代码重复，新开发的接口在完成业务逻辑后要织入一段业务操作日志保存的逻辑 已开发上线的接口，还要重新再修改织入业务操作日志保存的逻辑并测试，且每个接口需要织入的业务操作日志保存的逻辑是一样的 正面实现 方案一：javax.servlet.Filter（过滤器） 依赖于servlet容器 基于函数回调实现 拦截URL对应的请求request和响应response 链式传递请求request和响应response 结论：【适合处理请求内容和响应内容】【不适用细节记录】【获取不到特定方法，例如某个注解的标注方法】 方案二：org.springframework.web.servlet.HandlerInterceptor（拦截器） 依赖于SpringMVC框架 基于Java的反射机制实现（AOP思想） 拦截Controller中具体方法（请求处理程序） 用来做自定义预处理(带有禁止执行处理程序本身的选项)和自定义后处理，例如公共处理程序代码和授权检查 结论：【获取不到请求body的内容】【@ResponseBody标注的处理方法，获取不到响应数据】【可以获取特定方法，例如某个注解的标注方法】12345678910- 其他概念 - DispatcherServlet：【Spring的唯一Servlet】【使用HandlerMapping、HandlerAdapter进行请求分发】 - HandlerMapping：【处理器映射器】【请求找到Handler处理程序】 - HandlerAdapter：【处理器适配器】【执行Handler处理程序】- 为什么获取不到请求body？ - Servlet创建HttpServletRequest时不会获取getInputStream()，没有将流传递给拦截器 - Controller中能获取到是因为执行处理程序之前调用getInputStream()，将流传递过去了- 为什么这么设计？ - 设计上就是如此【提高效率、降低耦合度、提高灵活性】 - 解决：【1、自定义重写一个HttpServletRequestWrapper获取流参数】【2、自定义重写一个DispatcherServlet派发请求】 方案三：Spring AOP（切面） 对作用域没有限制，定义好切点 颗粒度更细：前置通知（@Before）、后置通知（@After）、返回后通知（@AfterReturning）、异常通知（@AfterThrowing）、环绕通知（@Around） 结论：【可以获取方法参数】【可以获取方法返回值】【可以修改返回值】 123456789101112131415161718192021222324252627282930313233343536373839package javax.servlet;import java.io.IOException;public interface Filter &#123; /** * 过滤器实例初始化（只调用一次） * * @param filterConfig 与正在初始化的过滤器实例相关联的配置信息 * * @throws ServletException 初始化失败抛异常 */ default void init(FilterConfig filterConfig) throws ServletException &#123;&#125; /** * 每次请求时，容器都会调用doFilter方法 * 此方法的典型实现将遵循以下模式: * 1。检查请求 * 2。修改请求对象，请求头 * 3。修改响应对象，响应头 * 4-1。使用FilterChain对象chain. dofilter()调用链中的下一个实体， * 4-2。或者不将请求、响应对传递给过滤器链中的下一个实体以阻止请求处理 * * @param request 要处理的请求 * @param response 与请求相关联的响应 * @param chain 链式调用，下一过滤器的访问 * * @throws IOException 如果在此过滤器处理请求期间发生I/O错误 * @throws ServletException 如果处理因任何其他原因失败 */ void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException; /** * 由web容器调用，表示过滤器正在退出。 * 此方法可以来清理所有被占用的资源(例如，内存、文件句柄、线程)，并确保任何持久状态都与过滤器在内存中的当前状态同步。 */ default void destroy() &#123;&#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package org.springframework.web.servlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.lang.Nullable;import org.springframework.web.method.HandlerMethod;/** * * 有关更多选项和详细信息，请参见&#123;@code org.springframework.web.servlet.AsyncHandlerInterceptor&#125; * 通常，每个HandlerMapping bean定义一个拦截器链，共享其粒度。 * 为了能够将某个拦截器链应用到一组处理程序，需要通过一个HandlerMapping bean映射所需的处理程序。拦截器本身在应用程序上下文中被定义为bean，由映射bean定义通过其“interceptors”属性引用。 */public interface HandlerInterceptor &#123; /** * 在【HandlerAdapter调用处理程序】之前调用 * 可以终止 * 作用：登录验证（判断用户是否登录）权限验证：判断用户是否有权访问资源（校验token） * @param request 当前HTTP请求 * @param response 当前HTTP响应 * @param handler 选择要执行的处理程序，用于类型或实例计算 * @return &#123;@code true&#125; 如果执行链应该继续下一个拦截器或处理程序本身。否则，DispatcherServlet假定这个拦截器已经处理了响应本身。 */ default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return true; &#125; /** * 在【HandlerAdapter调用处理程序】之后调用 * 在【DispatcherServlet呈现视图】之前调用 * 每个拦截器都可以对执行进行后处理，以执行链的相反顺序执行 * 作用：将Controller层返回来的参数进行一些修改，在ModelAndView中 * @param request 当前HTTP请求 * @param response 当前HTTP响应 * @param handler 启动异步执行的处理程序(或&#123;@link HandlerMethod&#125;)，用于类型或实例检查 * @param modelAndView 处理程序返回的&#123;@code ModelAndView&#125;(也可以是&#123;@code null&#125;) */ default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception &#123;&#125; /** * 在【DispatcherServlet呈现视图】之后调用 * 进行适当的资源清理。 * 作用：例如登录的时候，我们经常把用户信息放到ThreadLocal中，为了防止内存泄漏，就需要将其remove掉，该操作就是在这里执行的 * 注意: 只有&#123;@code preHandle&#125;方法成功完成并返回&#123;@code true&#125;时才会被调用! * 与&#123;@code postHandle&#125;方法一样，该方法将以相反的顺序在链中的每个拦截器上被调用，因此第一个拦截器将是最后一个被调用的。 * * @param request 当前HTTP请求 * @param response 当前HTTP响应 * @param handler 启动异步执行的处理程序(或&#123;@link HandlerMethod&#125;)，用于类型或实例检查 */ default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception &#123;&#125;&#125; Spring AOP（切面）实现 依赖 12345&lt;!-- aop依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt; 切入点：自定义注解 123456789101112@Target(&#123;ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface JQHLog &#123; /** * 功能名称 */ String name() default &quot;&quot;; /** * 功能描述 */ String descript() default &quot;&quot;;&#125; 切面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129@Component@Aspect@Slf4jpublic class LogAspect implements Ordered &#123; /** * 前后端不分离架构，如果统一异常处理执行顺序在@AfterThrowing之前，会出现@AfterThrowing中不执行情况。 * 前后端分离架构不会出现此问题。 * 解决：实现Ordered接口，并重写getOrder()方法，使其返回值为1，返回值越小，执行的顺序越靠前，使其执行顺序优先于全部异常处理类。 */ @Override public int getOrder() &#123; return 1; &#125; /** * 定义切点：自定义注解 */ @Pointcut(&quot;@annotation(com.example.uidemo.log.JQHLog)&quot;) public void pointcut()&#123;&#125; /** * 目标方法执行之前 * @param joinPoint */ @Before(&quot;pointcut()&quot;) public void before(JoinPoint joinPoint)&#123; print(&quot;@Before&quot;, joinPoint); &#125; /** * 目标方法执行之后 * @param joinPoint */ @After(&quot;pointcut()&quot;) public void after(JoinPoint joinPoint)&#123; print(&quot;@After&quot;, joinPoint); &#125; /** * 目标方法返回执行结果之后（可以修改返回值） * @param joinPoint */ @AfterReturning(pointcut = &quot;pointcut()&quot;, returning = &quot;obj&quot;) public Object afterReturning(JoinPoint joinPoint, Object obj)&#123; print(&quot;@AfterReturning&quot;, joinPoint); return obj; &#125; /** * 目标方法抛出异常后 * @param joinPoint * @param e */ @AfterThrowing(value = &quot;pointcut()&quot;,throwing = &quot;e&quot;) public void afterThrowing(JoinPoint joinPoint,Exception e)&#123; print(&quot;@AfterThrowing&quot;, joinPoint); &#125; /** * 可以使用ProceedingJoinPoint joinPoint，获取目标对象，通过动态代理，代理目标类执行，在目标对象执行前后均可 * @param joinPoint * @throws Throwable */ @Around(&quot;pointcut()&quot;) public Object around(ProceedingJoinPoint joinPoint) throws Throwable &#123; Object result = null; long beginTime = System.currentTimeMillis(); try &#123; result = joinPoint.proceed(); &#125; catch (Throwable e) &#123; throw new RuntimeException(&quot;执行失败&quot;,e); &#125; // 执行时长(毫秒) long time = System.currentTimeMillis() - beginTime; MethodSignature signature = (MethodSignature) joinPoint.getSignature(); Method method = signature.getMethod(); // 获取方法注解 JQHLog logAnnotation = method.getAnnotation(JQHLog.class); // 注解名 String name = logAnnotation.name(); // 注解描述 String descript = logAnnotation.descript(); // 类名 String className = joinPoint.getTarget().getClass().getName(); // 方法名 String methodName = joinPoint.getSignature().getName(); // 请求的方法参数值 Object[] args = joinPoint.getArgs(); // 请求的方法参数名称 LocalVariableTableParameterNameDiscoverer u = new LocalVariableTableParameterNameDiscoverer(); String[] paramNames = u.getParameterNames(method); if (args != null &amp;&amp; paramNames != null) &#123; String params = &quot;&quot;; for (int i = 0; i &lt; args.length; i++) &#123; params += &quot; &quot; + paramNames[i] + &quot;: &quot; + args[i]; &#125; &#125; // 请求request参数 ServletRequestAttributes attributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes(); // 请求ip String ip = attributes.getRequest().getRemoteHost(); // 请求路径 String requestURI = attributes.getRequest().getRequestURI(); // 请求方法 String requestMethod = attributes.getRequest().getMethod(); print(&quot;@Around&quot;, joinPoint); return result; &#125; /** * 打印基本信息 * @param msg * @param joinPoint */ public void print(String msg, JoinPoint joinPoint)&#123; Map info = new HashMap&lt;&gt;(); info.put(&quot;类名&quot;, joinPoint.getTarget().getClass().getName()); info.put(&quot;方法名&quot;, joinPoint.getSignature().getName()); // 请求参数 ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); if (attributes != null)&#123; info.put(&quot;请求ip&quot;, attributes.getRequest().getRemoteHost()); info.put(&quot;请求路径&quot;, attributes.getRequest().getRequestURI()); info.put(&quot;请求方法&quot;, attributes.getRequest().getMethod()); &#125; log.info(&quot;&#123;&#125;：&#123;&#125;&quot;, msg, info.toString()); &#125;&#125; 可能遇到的问题 单个类内的方法调用是不能够进入切面中的（@Transactional也有这问题） 原因：内部方法调用时并未使用代理对象进行代理 解决方法：内部调用时，拿到代理对象调用（用AopContext类来获取当前类的代理对象，前提：启动类上加@EnableAspectJAutoProxy(exposeProxy = true)）1234567/** * 强制获取代理对象，必须开启exposeProxy配置，否则获取不到当前代理对象 * @EnableAspectJAutoProxy(exposeProxy = true) */private XXXImpl getThis() &#123; return AopContext.currentProxy() != null ? (XXXImpl) AopContext.currentProxy() : this;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://chenkun18.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"系统日志","slug":"系统日志","permalink":"https://chenkun18.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97/"},{"name":"操作日志","slug":"操作日志","permalink":"https://chenkun18.github.io/tags/%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://chenkun18.github.io/tags/SpringBoot/"},{"name":"SpringBoot项目必备","slug":"SpringBoot项目必备","permalink":"https://chenkun18.github.io/tags/SpringBoot%E9%A1%B9%E7%9B%AE%E5%BF%85%E5%A4%87/"},{"name":"SpringBoot日志","slug":"SpringBoot日志","permalink":"https://chenkun18.github.io/tags/SpringBoot%E6%97%A5%E5%BF%97/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://chenkun18.github.io/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"Local类","slug":"后端/java/Local","date":"2023-11-09T07:03:28.000Z","updated":"2024-01-04T05:18:09.839Z","comments":true,"path":"2023/11/09/后端/java/Local/","link":"","permalink":"https://chenkun18.github.io/2023/11/09/%E5%90%8E%E7%AB%AF/java/Local/","excerpt":"","text":"作用 不同国家的语言、文字、数字、日期都有不同显示 Local可用根据系统语言对其进行显示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116import java.text.NumberFormat;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;import java.time.ZonedDateTime;import java.time.format.DateTimeFormatter;import java.time.format.FormatStyle;import java.util.Locale;import java.util.Set;public class Test &#123; public static void main(String[] args) &#123; /** * 获取当前的语言和国家 */ Locale defaultLocal = Locale.getDefault(); String country = defaultLocal.getCountry();// CN String displayCountry = defaultLocal.getDisplayCountry();// 中国 String displayCountry1 = defaultLocal.getDisplayCountry(Locale.ENGLISH);// China String iso3Country = defaultLocal.getISO3Country();// CHN String language = defaultLocal.getLanguage();// zh String iso3Language = defaultLocal.getISO3Language();// zho String displayLanguage = defaultLocal.getDisplayLanguage();// 中文 String displayLanguage1 = defaultLocal.getDisplayLanguage(Locale.ENGLISH);// Chinese String displayName = defaultLocal.getDisplayName();// 中文 (中国) /** * 获取所有的语言及国家 */ Locale[] locales = Locale.getAvailableLocales(); /** * 获取所有国家 */ String[] countries = Locale.getISOCountries(); /** * 获取所有的语言 */ String[] languages = Locale.getISOLanguages(); /** * 获取某个国家对应的标签 */ String s = Locale.US.toLanguageTag();// en-US /** * 获取某个国家对应的语言 */ String s2 = Locale.ENGLISH.toLanguageTag();// en /** * 构建Local */ Locale locale = Locale.forLanguageTag(&quot;en-US&quot;);// 使用标签生成Local Locale locale2 = new Locale(&quot;en&quot;);// 构造函数生成Local Locale locale3 = new Locale(&quot;en&quot;, &quot;US&quot;);// 构造函数生成Local Locale locale4 = Locale.CHINA; /** * 数字格式化 */ NumberFormat numberInstance = NumberFormat.getNumberInstance(Locale.CHINA); String format = numberInstance.format(123456.78);// 123,456.78 /** * 货币格式化 */ NumberFormat currencyInstance = NumberFormat.getCurrencyInstance(Locale.CHINA); String format1 = currencyInstance.format(123456.78);// ￥123,456.78 /** * 百分比格式化 */ NumberFormat percentInstance = NumberFormat.getPercentInstance(Locale.CHINA); String format2 = percentInstance.format(0.2);// /** * 时间日期格式化 * - 月份和星期的数字应该用本地语言 * - 年月日的顺序符合本地习惯 * - 公历可能并不是本地首选表示方法 * - 需考虑本地的时区 */ LocalDate localDate = LocalDate.now();// 2023-11-09 String format3 = DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT).format(localDate);// 23-11-9 String format31 = DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT).withLocale(Locale.ENGLISH).format(localDate);// 11/9/23 String format4 = DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM).format(localDate);// 2023-11-9 String format41 = DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM).withLocale(Locale.ENGLISH).format(localDate);// Nov 9, 2023 String format5 = DateTimeFormatter.ofLocalizedDate(FormatStyle.LONG).format(localDate);// 2023年11月9日 String format51 = DateTimeFormatter.ofLocalizedDate(FormatStyle.LONG).withLocale(Locale.ENGLISH).format(localDate);// November 9, 2023 String format6 = DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL).format(localDate);// 2023年11月9日 星期四 String format61 = DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL).withLocale(Locale.ENGLISH).format(localDate);// Thursday, November 9, 2023 LocalTime localTime = LocalTime.now();// 16:31:18.072 String format7 = DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT).format(localTime);// 下午4:29 String format71 = DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT).withLocale(Locale.ENGLISH).format(localTime);// 4:29 PM String format8 = DateTimeFormatter.ofLocalizedTime(FormatStyle.MEDIUM).format(localTime);// 16:29:49 String format81 = DateTimeFormatter.ofLocalizedTime(FormatStyle.MEDIUM).withLocale(Locale.ENGLISH).format(localTime);// 4:29:49 PM String format9 = DateTimeFormatter.ofLocalizedTime(FormatStyle.LONG).format(localTime);// 下午04时29分49秒// String format91 = DateTimeFormatter.ofLocalizedTime(FormatStyle.LONG).withLocale(Locale.ENGLISH).format(localTime);//// String format10 = DateTimeFormatter.ofLocalizedTime(FormatStyle.FULL).format(localTime);//// String format101 = DateTimeFormatter.ofLocalizedTime(FormatStyle.FULL).withLocale(Locale.ENGLISH).format(localTime);// LocalDateTime localDateTime = LocalDateTime.now();// 2023-11-09T16:31:18.072 String format11 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT).format(localDateTime);// 23-11-9 下午4:31 String format111 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT).withLocale(Locale.ENGLISH).format(localDateTime);// 11/9/23 4:31 PM String format12 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM).format(localDateTime);// 2023-11-9 16:31:18 String format121 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM).withLocale(Locale.ENGLISH).format(localDateTime);// Nov 9, 2023 4:31:18 PM String format13 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG).format(localDateTime);// 2023年11月9日 下午04时31分18秒// String format131 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG).withLocale(Locale.ENGLISH).format(localDateTime);//// String format14 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.FULL).format(localDateTime);//// String format141 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.FULL).withLocale(Locale.ENGLISH).format(localDateTime);// ZonedDateTime zonedDateTime = ZonedDateTime.now();// 2023-11-09T16:31:54.917+08:00[GMT+08:00] String format15 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT).format(zonedDateTime);// 23-11-9 下午4:31 String format151 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT).withLocale(Locale.ENGLISH).format(zonedDateTime);// 11/9/23 4:31 PM String format16 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM).format(zonedDateTime);// 2023-11-9 16:31:54 String format161 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM).withLocale(Locale.ENGLISH).format(zonedDateTime);// Nov 9, 2023 4:31:54 PM String format17 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG).format(zonedDateTime);// 2023年11月9日 下午04时31分54秒 String format171 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG).withLocale(Locale.ENGLISH).format(zonedDateTime);// November 9, 2023 4:31:54 PM GMT+08:00 String format18 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.FULL).format(zonedDateTime);// 2023年11月9日 星期四 下午04时31分54秒 GMT+08:00 String format181 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.FULL).withLocale(Locale.ENGLISH).format(zonedDateTime);// Thursday, November 9, 2023 4:31:54 PM GMT+08:00 &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://chenkun18.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"java.util类","slug":"java-util类","permalink":"https://chenkun18.github.io/tags/java-util%E7%B1%BB/"},{"name":"java国际化","slug":"java国际化","permalink":"https://chenkun18.github.io/tags/java%E5%9B%BD%E9%99%85%E5%8C%96/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://chenkun18.github.io/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"注解@Builder","slug":"后端/lombok/Builder","date":"2023-11-09T02:52:09.000Z","updated":"2023-11-09T06:20:00.822Z","comments":true,"path":"2023/11/09/后端/lombok/Builder/","link":"","permalink":"https://chenkun18.github.io/2023/11/09/%E5%90%8E%E7%AB%AF/lombok/Builder/","excerpt":"","text":"作用 它作用于类，将其变成建造者模式，可以以链的形式调用12345678910111213141516171819202122232425262728293031323334353637package lombok;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.CONSTRUCTOR&#125;)@Retention(RetentionPolicy.SOURCE)public @interface Builder &#123; String builderMethodName() default &quot;builder&quot;; String buildMethodName() default &quot;build&quot;; String builderClassName() default &quot;&quot;; boolean toBuilder() default false; AccessLevel access() default AccessLevel.PUBLIC; String setterPrefix() default &quot;&quot;; @Target(&#123;ElementType.FIELD&#125;) @Retention(RetentionPolicy.SOURCE) public @interface Default &#123; &#125; @Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;) @Retention(RetentionPolicy.SOURCE) public @interface ObtainVia &#123; String field() default &quot;&quot;; String method() default &quot;&quot;; boolean isStatic() default false; &#125;&#125; 原理： 编译时创建一个内部静态类，有和实体类相同的属性（构造器） 构造器：所有属性的set方法，返回值是this（链式调用）","categories":[{"name":"后端","slug":"后端","permalink":"https://chenkun18.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"lombok注解","slug":"lombok注解","permalink":"https://chenkun18.github.io/tags/lombok%E6%B3%A8%E8%A7%A3/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://chenkun18.github.io/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"注解@SneakyThrows","slug":"后端/lombok/SneakyThrows","date":"2023-11-08T06:40:20.000Z","updated":"2023-11-09T00:27:17.139Z","comments":true,"path":"2023/11/08/后端/lombok/SneakyThrows/","link":"","permalink":"https://chenkun18.github.io/2023/11/08/%E5%90%8E%E7%AB%AF/lombok/SneakyThrows/","excerpt":"","text":"作用 @SneakyThrows注解为代码生成一个tr&#123;&#125;catch&#123;&#125;块,并把异常向上抛出来 作用在方法、构造方法上123456789101112package lombok;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;ElementType.METHOD, ElementType.CONSTRUCTOR&#125;)@Retention(RetentionPolicy.SOURCE)public @interface SneakyThrows &#123; Class&lt;? extends Throwable&gt;[] value() default &#123;Throwable.class&#125;;&#125; java中常见的异常有两种： Exception即非运行时异常(编译异常) RuntimeException即运行时异常 正常情况：编译异常需要处理（增加tr&#123;&#125;catch&#123;&#125;或者方法抛出去）1234567public void hhh(User user)&#123; try &#123; int userId = user.getId(); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125;&#125; @SneakyThrows注解会自动为代码生成一个上面的tr&#123;&#125;catch&#123;&#125;块,并把异常向上抛出来（编辑器不会报错）1234@SneakyThrowspublic void hhh(User user)&#123; int userId = user.getId();&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://chenkun18.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"lombok注解","slug":"lombok注解","permalink":"https://chenkun18.github.io/tags/lombok%E6%B3%A8%E8%A7%A3/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://chenkun18.github.io/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"注解@CrossOrigin","slug":"后端/springboot/CrossOrigin","date":"2023-11-08T06:40:20.000Z","updated":"2024-01-10T03:18:09.684Z","comments":true,"path":"2023/11/08/后端/springboot/CrossOrigin/","link":"","permalink":"https://chenkun18.github.io/2023/11/08/%E5%90%8E%E7%AB%AF/springboot/CrossOrigin/","excerpt":"","text":"作用 原理：利用spring的拦截器实现往响应头里添加Access-Control-Allow-Origin等响应头信息 用在类、方法上1234567891011121314151617181920212223242526272829303132333435363738394041424344package org.springframework.web.bind.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.springframework.core.annotation.AliasFor;@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface CrossOrigin &#123; /** @deprecated */ @Deprecated String[] DEFAULT_ORIGINS = new String[]&#123;&quot;*&quot;&#125;; /** @deprecated */ @Deprecated String[] DEFAULT_ALLOWED_HEADERS = new String[]&#123;&quot;*&quot;&#125;; /** @deprecated */ @Deprecated boolean DEFAULT_ALLOW_CREDENTIALS = false; /** @deprecated */ @Deprecated long DEFAULT_MAX_AGE = 1800L; @AliasFor(&quot;origins&quot;) String[] value() default &#123;&#125;; @AliasFor(&quot;value&quot;) String[] origins() default &#123;&#125;; String[] originPatterns() default &#123;&#125;; String[] allowedHeaders() default &#123;&#125;; String[] exposedHeaders() default &#123;&#125;; RequestMethod[] methods() default &#123;&#125;; String allowCredentials() default &quot;&quot;; long maxAge() default -1L;&#125; 概念 浏览器的同源策略限制：是一个重要的安全策略 同源（同一个域）：URL的协议、主机 (域名) 、端口都一致 跨域：URL的协议、主机 (域名) 、端口有一个不同 解决方案： JSONP：通过script标签没有跨域限制的特性，进行资源的请求和获取（需要目标服务器进行配合，且仅支持get请求） CORS：Cross-Origin Resource sharing（跨域资源共享），是一种基于HTTP头的机制，服务端在响应头里添加Access-Control-Allow-Origin等响应头信息标记哪些域可以访问 服务器代理：同源策略主要是限制浏览器和服务器之间的请求，服务器与服务器之间并不存在跨域","categories":[{"name":"后端","slug":"后端","permalink":"https://chenkun18.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"跨域","slug":"跨域","permalink":"https://chenkun18.github.io/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://chenkun18.github.io/tags/SpringBoot/"},{"name":"SpringBoot注解","slug":"SpringBoot注解","permalink":"https://chenkun18.github.io/tags/SpringBoot%E6%B3%A8%E8%A7%A3/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://chenkun18.github.io/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"OnlyOffice Document Server教程","slug":"其他/onlyOfficeDocumentServer","date":"2023-11-03T07:58:33.000Z","updated":"2023-11-08T06:35:59.366Z","comments":true,"path":"2023/11/03/其他/onlyOfficeDocumentServer/","link":"","permalink":"https://chenkun18.github.io/2023/11/03/%E5%85%B6%E4%BB%96/onlyOfficeDocumentServer/","excerpt":"","text":"OnlyOffice Document Server教程 官网教程地址 开始基本概念 OnlyOffice是一个开源办公套件，包括文本文档、电子表格、演示文稿和可填写表格的编辑器。它提供了以下功能： 创建、编辑和查看文本文档、电子表格、演示文稿和可填写表格； 多人实时协作处理文件。 OnlyOffice还支持WOPI协议，该协议用于将您的应用程序与在线office集成。 OnlyOffice API用于让开发人员将OnlyOffice文档/电子表格/演示文稿编辑器集成到自己的网站中，并设置和管理编辑器。 API JavaScript文件通常可以在以下编辑器文件夹中找到： https://documentserver/web-apps/apps/api/documents/api.js 其中documentserver是Document server的服务器的地址。 要嵌入编辑器的目标HTML文件需要有一个占位符div标记，其中将传递有关编辑器参数的所有信息：12&lt;div id=&quot;placeholder&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://documentserver/web-apps/apps/api/documents/api.js&quot;&gt;&lt;/script&gt; 包含可变参数的页面代码如下所示：1var docEditor = new DocsAPI.DocEditor(&quot;placeholder&quot;, config); 其中config是一个对象：123456789101112config = &#123; &quot;document&quot;: &#123; &quot;fileType&quot;: &quot;docx&quot;, &quot;key&quot;: &quot;Khirz6zTPdfd7&quot;, &quot;title&quot;: &quot;Example Document Title.docx&quot;, &quot;url&quot;: &quot;https://example.com/url-to-example-document.docx&quot; &#125;, &quot;documentType&quot;: &quot;word&quot;, &quot;editorConfig&quot;: &#123; &quot;callbackUrl&quot;: &quot;https://example.com/url-to-callback.ashx&quot; &#125;&#125;; 其中example.com是文档管理和存储服务器地址。请参阅如何工作部分，以了解有关DocumentServer服务客户端-服务器交互的更多信息。 一切ok则docEditor对象可以用来调用文档编辑器方法。 上面的示例包括正确启动所需的所有参数。 还可以更改其他非强制性参数，以实现其他功能（更改文档的访问权限、显示文档的不同信息等）。请参阅高级参数部分，了解这些参数是什么以及如何更改它们。 为了防止替换重要参数，请以令牌的形式向请求添加加密签名。 获取OnlyOffice文档 可用于Windows、Linux和Docker。 要在本地服务器上安装，请按照OnlyOffice帮助中心中的说明进行操作： Windows安装 Linux安装 Docker安装 在使用API文档之前，如有必要，建议进行以下设置： 配置文件中配置服务器设置； 切换到HTTPS协议，以便使用SSL证书进行安全连接； 添加额外的字体，以增强编辑器的工作； 为应用程序界面添加您自己的颜色主题。 立即尝试 您可以打开各种文件类型进行编辑、查看、共同编辑、审查或查看重新命名的工作原理。 点击&lt;/&gt;按钮查看相应的示例源代码。 特定于语言的例子 各个语言的demo","categories":[{"name":"其他","slug":"其他","permalink":"https://chenkun18.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"OnlyOffice","slug":"OnlyOffice","permalink":"https://chenkun18.github.io/tags/OnlyOffice/"},{"name":"OnlyOffice Document Server","slug":"OnlyOffice-Document-Server","permalink":"https://chenkun18.github.io/tags/OnlyOffice-Document-Server/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://chenkun18.github.io/categories/%E5%85%B6%E4%BB%96/"}]},{"title":"OnlyOffice介绍及docker部署Document Server","slug":"其他/onlyoffice","date":"2023-11-02T05:27:26.000Z","updated":"2023-11-06T00:20:57.266Z","comments":true,"path":"2023/11/02/其他/onlyoffice/","link":"","permalink":"https://chenkun18.github.io/2023/11/02/%E5%85%B6%E4%BB%96/onlyoffice/","excerpt":"","text":"描述和功能描述 OnlyOffice是一个多端协同的 Office 办公套件，结合了文本文档、电子表格、演示文稿和表单的编辑器。 后端：JavaScript语言和Node.js构建服务器端脚本 前端：使用HTML5呈现文档元素。 编辑器的技术基础是HTML5 Canvas。画布是一个包含不同绘图元素的容器，如线条、形状、图形和框架。HTML结构中的每个对象都是独立处理的，而画布结构的其余部分不受该特定对象的操作的影响。这有助于保持高精度的显示，使内容浏览器和操作系统不可知，并在查看、编辑或打印文档时提供平等的文档呈现。 核心格式组是OOXML，它使套件与DOCX、XLSX和PPTX文件完全兼容，而其他格式则通过内部转换进行处理。 具有实时协同编辑、评论、在线聊天、版本历史记录、跟踪更改和文档比较等协作工具，并支持各种类型的共享权限，包括完全访问、仅查看、评论、审阅、填写表单和自定义筛选。 可以使用基于API通信或WOPI协议的集成应用程序在第三方环境中集成。 可以使用不同的方法在客户端的体系结构上进行部署，包括Windows和Linux服务器安装选项、Docker、Pod 结构 服务体系结构在OnlyOffice文档部署模型的数据安全性、性能和灵活性方面发挥着至关重要的作用。 客户端：浏览器中调用一个完整的文档编辑器应用程序，将大部分流程负载转移到客户端 服务器端只处理保存、传输文件更改和拼写检查等过程。 体系结构中的每个服务都可以单独托管在一个集群中，这还增加了容错能力，并允许根据环境构建自定义服务映射。 服务架构如下： 这样的架构设计使得一台32GB RAM的8核机器足以容纳1000个同时编辑的文档，假设每4秒对所有文档进行一次更改（1000个连接每秒250次更改）。 编辑功能支持的电子文件格式支持以下类型的格式用于查看和编辑： 查看 编辑 下载 文本文档 DOC, DOCX, DOTX, FB2, ODT, OTT, RTF, TXT, PDF, PDF&#x2F;A, HTML, EPUB, XPS, DjVu, XML, DOCXF, OFORM DOC, DOCX, DOTX, FB2, ODT, OTT, RTF, TXT, HTML, EPUB, XML, DOCXF, OFORM DOCX, DOTX, FB2, ODT, OTT, RTF, TXT, PDF, PDF&#x2F;A, HTML, EPUB, DOCXF, OFORM 电子表格 XLS, XLSX, XLTX, ODS,OTS, CSV XLS, XLSX, XLTX, ODS,OTS, CSV XLSX, XLTX, ODS,OTS, CSV, PDF,PDF&#x2F;A 演讲 PPT, PPTX, POTX, ODP, OTP, PPSX PPT, PPTX, POTX, ODP, OTP PPTX, POTX, ODP, OTP, PDF, PDF&#x2F;A, PNG, JPG 协作功能 允许在集成平台内的任意数量的用户之间协作编辑文档。 由于OnlyOffice Docs的架构意味着编辑器的客户端性能，在同一服务器上处理同一文档时，每个用户都可以独立于所有其他用户激活任何功能或选择任何模式。 这显著改进了许多方面的工作，包括使用撤消和重做命令独立恢复操作。这种方法还最小化了服务器负载，使设置变得轻量级。 协作功能包括： 灵活的共享权限：仅查看、完全访问、审阅、注释、填写表单、自定义筛选器。 两种协同编辑模式：快速（实时）和严格（段落锁定） 跟踪变化； 评论； 在评论中提及用户； 内置聊天； 版本和修订控制（版本历史）。 通过独立使用所有功能和协作模式，来自不同设备和客户端（包括网络套件、桌面和移动应用程序）的大量用户之间可以进行协作。 尽管大多数操作都是在OnlyOffice文档（文档服务器）中执行的，但有些功能在集成中依赖于与用户管理系统的通信。版本历史记录和提及等功能的可用性目前在每个集成中都有所不同。 数据安全 在设计上是安全的，这得益于自托管的部署模型。此外，在任何基础结构中存储和编辑文件时，它都提供了多种保护数据的功能： 为了保护流量，OnlyOffice使用HTTPS运行，而文档编辑连接则使用JWT进行额外保护。 共享中提供灵活的权限：使用完全访问、只读、评论、审阅或填写表单权限，允许或不允许修改电子表格中的筛选器，如果您愿意，还可以限制下载、复制和打印。 您还可以应用水印，以避免未经授权重新分发您的内容。 文件加密可用于文件和电子表格，包括保护整个工作簿和电子表格中的单独表格。 OnlyOffice具有内置功能，可帮助企业遵守HIPAA和欧盟隐私法规。 接口定制可以自定义OnlyOffice文档的界面，以增强使用套件时的体验。 选项 说明 界面主题 可以将界面主题分别设置为暗、亮和经典灯光。在某些集成中，可以在管理级别控制主题设置。 界面和文档缩放 编辑器支持100%、125%、150%、175%和200%的自动缩放。 手动文档缩放选项的范围从50%到200%。 工具栏、状态栏和标尺 可以隐藏主工具栏、状态栏和标尺以展开工作区域。 工具栏布局* 在设置中，可以在完整和紧凑的工具栏布局之间切换，并更改选项卡的颜色。 附加选项（适用于开发人员） 脚本级配置允许调整按钮和命令、公司和联系人信息、徽标等的显示。 整合机制通过基于API的连接器进行集成 基于API的集成是将OnlyOffice文档连接到文件存储和共享环境的一种随意方式，包括同步和共享服务、内容管理系统（CMS）和学习管理系统（LMS）。目前大多数可用的连接器都是基于API的。 开放式API允许构建应用程序，以集成OnlyOffice独有的任何功能，或将自定义重新构建功能集成到连接的存储中，为用户提供完整的体验。 基于API的集成方案 OnlyOffice文档（文档服务器）与第三方服务的集成需要一个额外的应用程序，该应用程序将数据转换为兼容的格式。此角色由连接器扮演。OnlyOffice团队创建自己的官方连接器，并协助合作伙伴和第三方开发人员创建此类应用程序。 集成应用程序结构 通过基于API的集成提供的功能*： 功能 说明 支持格式 用于查看和编辑：DOCX、XLSX、PPTX、PPSX、OFORM、DOCXF 仅供查看：PDF、DJVU、TXT、CSV、ODT、ODS、ODP、DOC、XLS、PPT、PPS、EPUB、RTF、HTML、HTM、MHT、XPS 协作模式 在实时和段落锁定协同编辑模式之间切换。 自定义 为编辑器设置界面语言和主题、隐藏聊天菜单按钮、更改“关于”部分中的信息、界面自定义，如调整标题和工具栏、品牌、连接插件 基本功能 查看、编辑、共同编辑、移动查看和编辑、简化查看（嵌入式） 其他操作：方法 以所选格式下载文件、将文件标记为收藏夹、显示带有消息的工具提示 其他操作：事件 关闭编辑器、打开文件位置、将文件从查看模式切换到编辑模式、重命名文档、管理文档访问权限、打开版本历史记录、插入存储中的图像、邮件合并、与存储中的文档进行比较、在书签位置获取打开文件的链接、以所需格式保存文件、在评论中提及其他用户、创建新文档 安全 IP地址白名单、使用JWT验证请求和防止未经授权访问 文档权限 查看、编辑、审查（文本文件）、评论、填写表格、修改内容控件（文本文档）、修改过滤器（电子表格）、复制到剪贴板、下载、打印、重命名 局限性 编辑器中提供的所有功能都可以集成。 实战开发OnlyOffice社区版 文档服务器：Document Server 社区服务器：Community Server 邮件服务器：Mail Server docker部署文档服务器 【官网教程】 1、拉取镜像： 1docker pull onlyoffice/documentserver 2、启动容器： 1234567docker run -itd -p 9000:80 --restart=always -v D:\\workNew\\study\\onlyoffice\\DocumentServer\\logs:/var/log/onlyoffice # 日志数据-v D:\\workNew\\study\\onlyoffice\\DocumentServer\\data:/var/www/onlyoffice/Data # ssl证书-v D:\\workNew\\study\\onlyoffice\\DocumentServer\\lib:/var/lib/onlyoffice # 文件缓存数据-v D:\\workNew\\study\\onlyoffice\\DocumentServer\\db:/var/lib/postgresql # 数据库-e JWT_SECRET=my_jwt_secret # JWT密钥，不设置会自动生成，也可以关闭【-e JWT_ENABLED=false】onlyoffice/documentserver # 镜像名 进入容器：docker exec -it ID /bin/bash 启动所有的内置服务：supervisorctl restart all 退出容器：exit 访问：http://IP:9000/ 页面包括 开发文档 查看密钥：1docker exec ID /var/www/onlyoffice/documentserver/npm/json -f /etc/onlyoffice/documentserver/local.json &#x27;services.CoAuthoring.secret.session.string&#x27; 启动example服务：1docker exec ID sudo supervisorctl start ds:example 设置example服务自动启动：1docker exec ID sudo sed &#x27;s,autostart=false,autostart=true,&#x27; -i /etc/supervisor/conf.d/ds-example.conf 服务列表（都是通过pkg打包成可执行文件，摆脱node环境的依赖） ds:converter：转换器 ds:docservice：文档服务 ds:example：例子 ds:metrics 服务占用端口： nginx：80 rabbitmq：5672、25672、4369 postgres：5432 docservice: 8000 example：3000 example测试","categories":[{"name":"其他","slug":"其他","permalink":"https://chenkun18.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"OnlyOffice","slug":"OnlyOffice","permalink":"https://chenkun18.github.io/tags/OnlyOffice/"},{"name":"OnlyOffice Docker部署Document Server","slug":"OnlyOffice-Docker部署Document-Server","permalink":"https://chenkun18.github.io/tags/OnlyOffice-Docker%E9%83%A8%E7%BD%B2Document-Server/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://chenkun18.github.io/categories/%E5%85%B6%E4%BB%96/"}]},{"title":"hexo博客搭建","slug":"其他/hexo","date":"2023-10-31T16:00:00.000Z","updated":"2023-11-06T00:20:57.244Z","comments":true,"path":"2023/11/01/其他/hexo/","link":"","permalink":"https://chenkun18.github.io/2023/11/01/%E5%85%B6%E4%BB%96/hexo/","excerpt":"","text":"什么是 Hexo？ 一个快速、简洁且高效的博客框架【Hexo中文官网】 本地环境 nodejs git 本地项目搭建 1、安装hexo客户端：npm install -g hexo-cli 2、新建一个文件夹：myblog 3、初始化hexo，在文件夹下执行：hexo init 目录结构 node_modules: 依赖包 scaffolds：生成文章的一些模板 source：用来存放你的文章 themes：主题 _config.yml: 博客的配置文件 4、启动运行：hexo server 5、访问http://localhost:4000/ 新增主题 官网选择需要的主题【主题选择网址】 我这里选择snippet 进入themes目录下把代码拉下来：git clone https://github.com/shenliyang/hexo-theme-snippet.git _config.yml文件中配置主题：theme: hexo-theme-snippet 重新启动运行：hexo server 每种主题有哪些配置可以看md文件，根据自己需求进行配置 写博客 新建分类：hexo new page &quot;categories&quot; 新建标签：hexo new page &quot;tags&quot; 新建文章：hexo new 文件名（会在_posts下生成md文件） 文件内容（前面是配置标题、时间、分类、标签，后面就可以写文章了）12345678910---title: 文件名date: 2023-11-02 10:41:01category: 哈哈tags: - xxx - hhh---# 标题1- 哈哈哈 md文件中如何插入图片等资源【官网资源配置】 我是建一个和md文件名相同的文件夹，然后将图片放下面 部署到github 教程：【官网教程】 1、新建一个github仓库，仓库名为账号名.github.io，新建md文件初始化main分支 2、新建一个source分支，新建md文件初始化source分支 3、本地拉取source分支代码 然后将你本地的之前博客项目的文件都复制过去（除了.deploy_git,.github,.git等文件，themes下的主题中.github也删掉） 并新建一个.gitignore文件，内容如下12345678910.DS_Store.idea/Thumbs.dbdb.json*.lognode_modules/public/.deploy*/_multiconfig.ymlpackage-lock.json 4、把代码推送到source分支 5、电脑配置git ssh公钥自行百度 6、安装部署插件npm install hexo-deployer-git --save _config.yml文件中配置部署:123456# Deployment 部署配置## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git #仓库类型 repo: git@github.com:AAAJQHAAA/aaajqhaaa.github.io.git #仓库地址 branch: main #主分支 7、打包部署，编译后的文件会推送到主分支 清除：npm run clean 打包：npm run build 部署：npm run deploy 8、github配置访问 settings-pages-Source-选择部署主分支 然后就可以访问了账号名.github.io","categories":[{"name":"其他","slug":"其他","permalink":"https://chenkun18.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://chenkun18.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://chenkun18.github.io/categories/%E5%85%B6%E4%BB%96/"}]}]}